
#[cfg(test)]
mod test_normal {
    use std::fs::{File, OpenOptions};
    use std::path::Path;
    use binlog::decoder::binlog_decoder::{BinlogReader, FileBinlogReader};
    use binlog::events::event::Event;
    use binlog::events::event::Event::{Query, TableMap, WriteRows};
    use binlog::events::protocol::query_event::QueryEvent;
    use binlog::events::protocol::table_map_event::TableMapEvent;
    use binlog::events::protocol::write_rows_v12_event::WriteRowsEvent;
    use common::log::log_factory::LogFactory;

    #[test]
    fn test() {
        LogFactory::init_log(true);

        println!("test");
    }

    #[test]
    fn test_query_default() {
        let file = load_read_only_file("C:/Workspace/test_data/8.0/02_query/binlog.000001");
        let reader = FileBinlogReader::new(file).unwrap();

        let mut output = Vec::<Event>::new();
        for result in reader.read_events() {
            let (header, event) = result.unwrap();

            println!("============================ {}", Event::get_type_name(&event));
            // println!("{:#?}", header);
            // println!("{:#?}", event.clone());
            // println!("");

            output.push(event);
        }

        match output.get(3).unwrap() {
            Query(QueryEvent{
                      thread_id,
                      schema_length,
                      schema,
                      query,
                          ..
                      })  => {
                assert_eq!(*thread_id, 8);
                assert_eq!(*schema_length, 4);
                assert_eq!(*schema, "test");
                assert_eq!(*query, "DROP TABLE IF EXISTS `boxercrab` /* generated by server */");
            }
            _ => panic!("should QueryEvent"),
        }
    }

    #[test]
    fn test_table_map_event_write_rows_log_event() {
        let file = load_read_only_file("C:/Workspace/test_data/8.0/19_30_Table_map_event_Write_rows_log_event/binlog.000018");
        let reader = FileBinlogReader::new(file).unwrap();

        let mut output = Vec::<Event>::new();
        for result in reader.read_events() {
            let (header, event) = result.unwrap();
            println!("============================ {}", Event::get_type_name(&event));
            // println!("{:#?}", header);
            // println!("{:#?}", event.clone());
            // println!("");

            output.push(event);
        }

        match output.get(8).unwrap() {
            TableMap(TableMapEvent{
                         table_id,
                         flags,
                         table_name,
                         column_metadata,
                      ..
                  })  => {
                assert_eq!(*table_id, 90);
                assert_eq!(*flags, 1);
                assert_eq!(*table_name, "int_table");
                assert_eq!(*column_metadata, vec![0, 0, 0, 0, 0, 0]);
            }
            _ => panic!("should TableMapEvent"),
        }

        match output.get(9).unwrap() {
            WriteRows(WriteRowsEvent{
                          table_id,
                          columns_number,
                          columns_present,
                          rows,
                      ..
                  })  => {
                assert_eq!(*table_id, 90);
                assert_eq!(*columns_number, 6);
            }
            _ => panic!("should WriteRowsEvent"),
        }
    }

    fn load_read_only_file(name: &str) -> File {
        let path = Path::new(name);
        let exists = path.exists();

        OpenOptions::new()
            .read(true)
            // .append(true)
            // .write(true)
            // .create(true)
            .open(path)
            .unwrap()
    }

}